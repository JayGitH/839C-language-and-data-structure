/*
	Name: 对二维数组使用指针进行操作的探索 
	Copyright: 
	Author: lingr7
	Date: 01/12/18 11:55
	Description: 
*/
#include<stdio.h>
int main() {

    int a[2][3] = {{1,2,3},{4,5,6}};
    int **p = a;/*这一步，将a存放的地址赋值给了p，这一步是的p与a完全等价*/
    int *p2 = p;/*这一步就将a[0][0]的地址确实地存入了p2，
	与int *p2 = a;语句完全等价，同时进行了强制转换*/
    
    printf("a[1][2]的值:%d\n", *(p2 + 1*3 + 2));/*对二维数组访问成功*/
    printf("a[1][2]的值:%d\n", *((int*)p + 1*3 + 2));/*访问成功*/
    printf("a[1][2]的值:%d\n", *((int*)a + 1*3 + 2));/*对二维数组访问成功*/
   /* 既然(int*)a与 *(int(*)[3])a在这里是等价的，那么还是(int*)a更方便一点*/
	printf("a[1][0]的值:%d\n", *(*(int(*)[3])a+1*3+0));/*访问成功*/
	printf("a[1][0]的值:%d\n", *(*(int(*)[3])p+1*3+0));/*访问成功*/
	/*以上能够正确的访问二维数组*/
	
    printf("a[1][0]的值:%d\n", *(a+1*3+0));/*这里因为a的地址的多重性而混乱，必须强制转换确认
	a是一个指向整型元素的指针，才能正确使用a里存放的地址*/
	printf("a[1][0]的值:%d\n", *(*(int(*)[3])p+1*3+0));/*p与a的效果完全一样*/
	/*printf("a[1][0]的值:%d\n", *(*(int*)p+1*3+0));/*编译不通过*/
	printf("a[1][0]的值:%d\n", *((int*)*p+1*3+0));/*操作失败*/
	printf("a[1][0]的值:%d\n", *((int*)(*p)+1*3+0));/*操作失败*/
    printf("a[1][0]的值:%d\n", *(p+1));
    printf("*p应该是一个指向指针的指针:%d", *p);
    printf("\n");
    printf("a的地址:%d\n", a);
    printf("a[0][0]的地址:%d\n",&a[0][0]);
    printf("a[0][0]的值:%d\n", *p);
    printf("a[1][2]的值:%d\n", *(p + 1*3 + 2));/*这里和int *p = a的结果不同*/
    printf("a[1][2]的值:%d\n", *p + 1*3 + 2);/*21，这里应该是5才对啊
	这里跟对二维数组的操作无关，因为*p指向一个指向整型的指针，可是*P移位根本不确定，*P移位后指向什么东西*/
    /*printf("a[1][2]的值:%d\n", *(*p + 1*3 + 2));/*存储地址为21的东西没办法输出*/
    printf("a[0][0]的值:%d\n", *(p+1));
    printf("p+1之前：%d\n",p);
    p++;
    printf("p+1之后：%d\n",p);/*地址+1，实际上是10进制加8了，这是因为p是一个指针，+1之后是下一个
	而p指向一个指针，对p移位所以是下一个存储地址长度，与p指向的那个指针指向的类型无关*/

}
