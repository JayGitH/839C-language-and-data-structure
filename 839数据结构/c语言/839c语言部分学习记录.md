# 839c语言部分学习记录

对《C程序设计语言》ISBN: 9787111128069学习过程进行记录

## 第1章 导言

### 关于EOF

![](http://ww1.sinaimg.cn/large/005yt5eJly1fuqg5ybxr1j30co05jdfn.jpg)

####1-6

正解代码

```c
#include <stdio.h>
/* copy input to output; 1st version */
main()
{
	int c;
	//c = getchar();
	while (c = (getchar() != EOF) ){
		printf("%d\n", c); 
	}
	printf("%d - at EOF\n", c);
}
/**/
```

![](http://ww1.sinaimg.cn/large/005yt5eJly1furpufamk2j30ck06y0sj.jpg)

这里为什么输入一个字符，1会输出两次,因为回车也是一个输入字符啊。

```c
100100100200
1
1
1
1
1
1
1
1
1
1
1
1
1
```

```c
#include <stdio.h>
/* copy input to output; 1st version */
main()
{
	int c;
	//c = getchar();
	int i = 0;
	while (c = (getchar() != EOF) )
		printf("%d %d\n", c, i++); 
	printf("%d - at EOF\n", c);
}
/*在while判断里，c = 非0值，则满足条件，进入循环，当c赋值为0，则为假，退出循环*/
```

在8月7日，那位Hurricane在8月28日刷完了，k&r书上的所有习题和例子，大约是过了21天的时间做完了，看来我也是要尽快完成这一步。

当然，真题答案也是必要的。

#### 1-7

```c
#include <stdio.h>
main()
{
	printf("EOF is %d\n", EOF);
}
```

非引号引起的部分，都会被文本替换。

```
EOF is -1
```

```C
#define EOF (-1)
```
为了保证直接文本替换时不出问题，还加上括号了。

#### 1-8

```c
#include <stdio.h>
main(){
	int c, n1, n2, n3;
	n1 = 0;
	n2 = 0;
	n3 = 0;
	while((c = getchar()) != EOF){
		if(c == 32)//空格 ' '
			n1++;
		else if(c == 9)//制表符'\t'
			n2++;
		else if(c == 10) //换行符'\n'
			n3++;
		
	} 
	printf("%d %d %d\n", n1, n2, n3);
}
```



###速查ASCII码

| ASCII值 | 控制字符 | ASCII值 | 控制字符 | ASCII值 | 控制字符 | ASCII值 | 控制字符 |
| ------- | -------- | ------- | -------- | ------- | -------- | ------- | -------- |
| 0       | NUT      | 32      | (space)  | 64      | @        | 96      | 、       |
| 1       | SOH      | 33      | !        | 65      | A        | 97      | a        |
| 2       | STX      | 34      | "        | 66      | B        | 98      | b        |
| 3       | ETX      | 35      | #        | 67      | C        | 99      | c        |
| 4       | EOT      | 36      | $        | 68      | D        | 100     | d        |
| 5       | ENQ      | 37      | %        | 69      | E        | 101     | e        |
| 6       | ACK      | 38      | &        | 70      | F        | 102     | f        |
| 7       | BEL      | 39      | ,        | 71      | G        | 103     | g        |
| 8       | BS       | 40      | (        | 72      | H        | 104     | h        |
| 9       | HT       | 41      | )        | 73      | I        | 105     | i        |
| 10      | LF       | 42      | *        | 74      | J        | 106     | j        |
| 11      | VT       | 43      | +        | 75      | K        | 107     | k        |
| 12      | FF       | 44      | ,        | 76      | L        | 108     | l        |
| 13      | CR       | 45      | -        | 77      | M        | 109     | m        |
| 14      | SO       | 46      | .        | 78      | N        | 110     | n        |
| 15      | SI       | 47      | /        | 79      | O        | 111     | o        |
| 16      | DLE      | 48      | 0        | 80      | P        | 112     | p        |
| 17      | DCI      | 49      | 1        | 81      | Q        | 113     | q        |
| 18      | DC2      | 50      | 2        | 82      | R        | 114     | r        |
| 19      | DC3      | 51      | 3        | 83      | S        | 115     | s        |
| 20      | DC4      | 52      | 4        | 84      | T        | 116     | t        |
| 21      | NAK      | 53      | 5        | 85      | U        | 117     | u        |
| 22      | SYN      | 54      | 6        | 86      | V        | 118     | v        |
| 23      | TB       | 55      | 7        | 87      | W        | 119     | w        |
| 24      | CAN      | 56      | 8        | 88      | X        | 120     | x        |
| 25      | EM       | 57      | 9        | 89      | Y        | 121     | y        |
| 26      | SUB      | 58      | :        | 90      | Z        | 122     | z        |
| 27      | ESC      | 59      | ;        | 91      | [        | 123     | {        |
| 28      | FS       | 60      | <        | 92      | /        | 124     | \|       |
| 29      | GS       | 61      | =        | 93      | ]        | 125     | }        |
| 30      | RS       | 62      | >        | 94      | ^        | 126     | `        |
| 31      | US       | 63      | ?        | 95      | _        | 127     | DEL      |

| NUL空        | VT 垂直制表   | SYN 空转同步  |
| ------------ | ------------- | ------------- |
| STX 正文开始 | CR 回车       | CAN 作废      |
| ETX 正文结束 | SO 移位输出   | EM 纸尽       |
| EOY 传输结束 | SI 移位输入   | SUB 换置      |
| ENQ 询问字符 | DLE 空格      | ESC 换码      |
| ACK 承认     | DC1 设备控制1 | FS 文字分隔符 |
| BEL 报警     | DC2 设备控制2 | GS 组分隔符   |
| BS 退一格    | DC3 设备控制3 | RS 记录分隔符 |
| HT 横向列表  | DC4 设备控制4 | US 单元分隔符 |
| LF 换行      | NAK 否定      | DEL 删除      |

```
空白符的含义模糊，通常是指空格' '，其ASCII码为32。 
制表符为'\t'，相当于4个或8个空格符，其ASCII码为9。 
换行符为'\n'，作用是将光标移至下一行，其ASCII码为10。 
此外，还有回车'\r'，作用是让光标移至行首，其ASCII码为13。 
Windows下换行是\n\r，Unix系统下是\n。 
除了水平制表符'\t'，还有垂直制表符'\v'，这个[转义字符]只有在打印机中才能显示出来，显示屏不起作用的，其ACSII码为11。
```

#### 1-9

```c
#include <stdio.h>
#define NONBLANK 'a'
main(){
	int c, lastc;
	lastc = NONBLANK;
	while((c = getchar()) != EOF){
		if ( c != ' ')
			putchar(c);
		else if (lastc != ' ')
			putchar(c);
		lastc = c;
	}
		
}
```

####1-10

```C
#include <stdio.h>
#define NONBLANK 'a'
main(){
	int c, lastc;
	lastc = NONBLANK;
	while((c = getchar()) != EOF){
		if ( c == '\t')
			printf("\\t");
		else if (c == '\b')
			printf("\\b");
		else if (c == '\=')
			printf("\\");
		else putchar(c);
	}
		
}
```

#### 1-12

```c
#include <stdio.h>
#define IN 1/*inside a word		*/
#define OUT 0/*outside a word 	*/
/*print input one word per line */
main(){
	int c, state;
	state = OUT;
	while((c = getchar()) != EOF){
		if ( c == ' ' || c == '\n' || c == '\t'){
			if (state == IN) {/*finish word*/
				putchar('\n');
				state = OUT;
			}	
		} else if (state == OUT) {/*begin the word*/
			state = IN;
			putchar(c);
		} else
			putchar(c);/*inside word*/
	}
		
}
```

#### 1-13

```c
#include <stdio.h>

#define MAXHIST 15		/*max length of histogram	*/
#define MAXWORD 11		/*max length of a word		*/
#define IN		1		/*inside a word 			*/
#define OUT		0		/*outside a word 			*/

/*print horzontal histogram							*/
main(){
	int c, i, nc, state;
	int len;			/*length of each other		*/
	int maxvalue;		/*maximum value for wl[]	*/
	int ovflow;			/*number of overflow words	*/
	int wl[MAXWORD];	/*word length counters		*/
	
	state = OUT;
	nc = 0;				/*number of chars in a word */
	ovflow = 0;			/*number of words >= MAXWORD*/
	for (i = 0; i < MAXWORD; ++i)
		wl[i] = 0;
	while ((c = getchar()) != EOF) {
		if (c == ' ' || c == '\n' || c == '\t'){
			state = OUT;
			if (nc > 0)
				if (nc < MAXWORD)
					++wl[nc];
				else 
					++ovflow;
			nc = 0;
		} else if (state == OUT){
			state = IN;
			nc = 1;		/*beginning of a new word	*/
		}else
			++nc;		/*inside a word				*/
	}
	/*手动到达EOF才会执行下面的代码*/
	maxvalue = 0;
	for (i = 1; i < MAXWORD; ++i)
		if(wl[i] > maxvalue)
			maxvalue = wl[i];
	for (i = 1; i < MAXWORD; ++i){
		printf("%5d - %5d : ", i, wl[i]);
		if (wl[i] > 0){
				if ((len = wl[i] * MAXHIST / maxvalue) <= 0)
					len = 1;
		} else
			len = 0;
		while (len > 0){
			putchar('*');
			--len;
		}
		putchar('\n');
	}
	if (ovflow > 0)
			printf("There are %d words >= %d\n", ovflow, MAXWORD);
}
```

```c
#include <stdio.h>

#define MAXHIST 15		/*max length of histogram	*/
#define MAXWORD 11		/*max length of a word		*/
#define IN		1		/*inside a word 			*/
#define OUT		0		/*outside a word 			*/

/*print vertical histogram							*/
main(){
	int c, i, j, nc, state;
	int len;			/*length of each other		*/
	int maxvalue;		/*maximum value for wl[]	*/
	int ovflow;			/*number of overflow words	*/
	int wl[MAXWORD];	/*word length counters		*/
	
	state = OUT;
	nc = 0;				/*number of chars in a word */
	ovflow = 0;			/*number of words >= MAXWORD*/
	for (i = 0; i < MAXWORD; ++i)
		wl[i] = 0;
	while ((c = getchar()) != EOF) {
		if (c == ' ' || c == '\n' || c == '\t'){
			state = OUT;
			if (nc > 0)
				if (nc < MAXWORD)
					++wl[nc];
				else 
					++ovflow;
			nc = 0;
		} else if (state == OUT){
			state = IN;
			nc = 1;		/*beginning of a new word	*/
		}else
			++nc;		/*inside a word				*/
	}
	/*手动到达EOF才会执行下面的代码*/
	maxvalue = 0;
	for (i = 1; i < MAXWORD; ++i)
		if(wl[i] > maxvalue)
			maxvalue = wl[i];
	/*以上与水平直方图完全相同*/
	for (i = MAXHIST; i > 0; --i){
		for (j = 1; j < MAXWORD; ++j){
			if(wl[j] * MAXHIST / maxvalue >= i)
				printf("   * ");
			else 
				printf("     ");
		}
		putchar('\n');
	}
	for (i = 1; i < MAXWORD; ++i)
		printf("%4d ", i);
	putchar('\n');
	for (i = 1; i < MAXWORD; ++i)
		printf("%4d ", wl[i]);
	putchar('\n');
	if (ovflow > 0)
			printf("There are %d words >= %d\n", ovflow, MAXWORD);
}
```

![](http://ww1.sinaimg.cn/large/005yt5eJgy1fus07bif4qj30qr0bmjrg.jpg)

然而不能对着电脑，而是对着卷子编程总是怪怪的，不面对真题，没有考研的真实感啊，确实如此啊。

#### 1-14

```c
#include <stdio.h>
#include <ctype.h>

#define MAXHIST 15		/*max length of histogram			*/
#define MAXCHAR 128		/*max different characters			*/

/*print horizontal histogram freq. of different characters	*/
main(){
	int c, i;
	int len;			/*length of each bar		*/
	int maxvalue;		/*maximum value for cc[]	*/
	int cc[MAXCHAR];	/*character counters		*/
	
	for (i = 0; i < MAXCHAR; ++i)
		cc[i] = 0;
	while ((c = getchar()) != EOF) {
		if (c < MAXCHAR ){
			++cc[c];
		}
	}
	/*手动到达EOF才会执行下面的代码*/
	/*找到出现次数最多的*/
	maxvalue = 0;
	for (i = 1; i < MAXCHAR; ++i)
		if(cc[i] > maxvalue)
			maxvalue = cc[i];
			
	for (i = 1; i < MAXCHAR; ++i){
		if (isprint(i))
			printf("%5d - %c - %5d : ", i, i, cc[i]);//此处体现了数字%c显示该asc2码得其对应字符 
		else
			printf("%5d -    - %5d : ", i, cc[i]);
		if (cc[i] > 0){
			if ((len = cc[i] * MAXHIST / maxvalue) <= 0)
				len = 1;
		} else 
			len = 0;
			
		while (len > 0){
			putchar('*');
			--len;
		}
		putchar('\n');
	}
}
```

#### 1-16

```c
#include <stdio.h>    //    包含标准库的信息。

#define MAXLINE 10

int getline(char line[], int maxline);

int main()    //    定义名为main的函数，它不接受参数值。
{
    int len;
    int max;
    char line[MAXLINE];
    while ((max = getline(line, MAXLINE)) > 0)
    {
        printf("输入的行的字符数为：%d。内容是%s\n", max, line);
    }
    printf("程序结束。");

    getchar();    //    防止控制台一闪而过，需要接受任意字符后在关闭控制台。
    return 0;    //    向执行环境返回一个整形，0代表执行成功。
}

int getline(char s[], int lim)
{
    int c, i, j;
    j = 0;
    for (i = 0; (c = getchar()) != EOF && c != '\n'; ++i)
    {
        if (i <= lim - 2) //    如果数组还剩下一个就装满了，则不在将字符放入数组。
            s[i] = c;
        ++j;    //    但行字符计数器仍然+1。
    }
    if(j > lim)
        s[lim - 1] = '\0';    //    如果输入的字符长度大于数组长度，则数组最后一位写入'\0'。
    else 
        s[i + 1] = '\0';            //    否则将有效字符后写入'\0'。
    return j;
}
```

```c
#include <stdio.h>
#define MAXLINE 1000 /* maximum input line length */

int getline(char line[], int maxline);
void copy(char to[], char from[]);
/* print the longest input line */
main()
{
	int len; /* current line length */
	int max; /* maximum length seen so far */
	char line[MAXLINE]; /* current input line */
	char longest[MAXLINE]; /* longest line saved here */
	
	max = 0;
	while ((len = getline(line, MAXLINE)) > 0){
		printf("%d, %s", len, line);
		if (len > max) {
			max = len;
			copy(longest, line);
		}
	}
		
		
	if (max > 0) /* there was a line */
		printf("%s", longest);
	return 0;
}
/* getline: read a line into s, return length */
int getline(char s[],int lim)
{
	int c, i, j;
	j = 0;
	for (i=0; (c=getchar())!=EOF && c!='\n'; ++i)
		if (i < lim-2 ){
			s[j] = c;
			++j;
		}
	if (c == '\n') {
		s[j] = c;
		++i;
		++j;
	}
	s[j] = '\0';
	return i;
}
/* copy: copy 'from' into 'to'; assume to is big enough */
void copy(char to[], char from[])
{
	int i;
	i = 0;
	while ((to[i] = from[i]) != '\0')
		++i;
}
```

#### 1-17

```c
#include <stdio.h>
#define MAXLINE 1000 /* maximum input line length */
#define LONGLINE 80
int getline(char line[], int maxline);
void copy(char to[], char from[]);
/* print the longest input line */
main()
{
	int len; /* current line length */
	int max; /* maximum length seen so far */
	char line[MAXLINE]; /* current input line */
	char longest[MAXLINE]; /* longest line saved here */
	
	max = 0;
	while ((len = getline(line, MAXLINE)) > LONGLINE){
		printf("%d, %s", len, line);
	}
	return 0;
}
/* getline: read a line into s, return length */
int getline(char s[],int lim)
{
	int c, i, j;
	j = 0;
	for (i=0; (c=getchar())!=EOF && c!='\n'; ++i)
		if (i < lim-2 ){
			s[j] = c;
			++j;
		}
	if (c == '\n') {
		s[j] = c;
		++i;
		++j;
	}
	s[j] = '\0';
	return i;
}

```

