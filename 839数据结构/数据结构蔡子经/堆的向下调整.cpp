/*
	Name: 最大堆的向下调整 
	Copyright: 
	Author: lingr7
	Date: 29/11/18 17:10
	Description: 
*/
void siftdown(int a[], int i, int n){/* n是下标最大值（取不到）*/
	int j;
	int t;
	t = a[i];/*保存此时根的值，此时a[i]中还不一定是堆的最大值，从此根结点
	以下是最大堆的结构*/
	while(( j = 2*i+1 < n)){/*即某左子结点还存在*/
		if(j < n-1 && a[j] < a[j+1])
			j++;/*判断是否有右子结点，以及是否对右子节点先处理，
			找其中较大的那个先处理*/
		if(t < a[j])/*下放到a[j]之下吗？*/
			{
				a[(j-1)/2] = a[j];/*将值赋给父节点*/
				i = j;/*继续找下一层节点，看下面有无需要调整的*/
			}
		else break;
	}/*如果遇到不用调整的，或者是遇到t>=a[j]的，那把t值放到a[j]的父节点即可*/
	a[(j-1)/2] = t;/*不用调整，等于未操作。*/
}
